/* tslint:disable */
/* eslint-disable */
/**
 * Karetsaka Api
 * Karetsaka
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface ApiResponseError
 */
export interface ApiResponseError {
  /**
   *
   * @type {number}
   * @memberof ApiResponseError
   */
  statusCode: number;
  /**
   *
   * @type {string}
   * @memberof ApiResponseError
   */
  message: string;
}
/**
 *
 * @export
 * @interface Appointment
 */
export interface Appointment {
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  firstName: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  contact: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  appointmentDate: string;
  /**
   *
   * @type {string}
   * @memberof Appointment
   */
  status: AppointmentStatusEnum;
}

export const AppointmentStatusEnum = {
  Pending: "PENDING",
  Validated: "VALIDATED",
  Rejected: "REJECTED",
  Archived: "ARCHIVED",
} as const;

export type AppointmentStatusEnum =
  (typeof AppointmentStatusEnum)[keyof typeof AppointmentStatusEnum];

/**
 *
 * @export
 * @interface Car
 */
export interface Car {
  /**
   *
   * @type {string}
   * @memberof Car
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Car
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof Car
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof Car
   */
  model: string;
  /**
   *
   * @type {number}
   * @memberof Car
   */
  price: number;
  /**
   *
   * @type {Array<string>}
   * @memberof Car
   */
  color: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Car
   */
  motorType: CarMotorTypeEnum;
  /**
   *
   * @type {number}
   * @memberof Car
   */
  power: number;
  /**
   *
   * @type {number}
   * @memberof Car
   */
  placeNumber: number;
  /**
   *
   * @type {boolean}
   * @memberof Car
   */
  status: boolean;
  /**
   *
   * @type {string}
   * @memberof Car
   */
  type: string;
  /**
   *
   * @type {CarBrand}
   * @memberof Car
   */
  brand: CarBrand;
}

export const CarMotorTypeEnum = {
  Gasoline: "GASOLINE",
  Diesel: "DIESEL",
  Hybrid: "HYBRID",
  Electric: "ELECTRIC",
} as const;

export type CarMotorTypeEnum =
  (typeof CarMotorTypeEnum)[keyof typeof CarMotorTypeEnum];

/**
 *
 * @export
 * @interface CarBrand
 */
export interface CarBrand {
  /**
   *
   * @type {string}
   * @memberof CarBrand
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CarBrand
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CarBrand
   */
  picture?: string;
}
/**
 *
 * @export
 * @interface CrupdateCar
 */
export interface CrupdateCar {
  /**
   *
   * @type {string}
   * @memberof CrupdateCar
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateCar
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateCar
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateCar
   */
  model: string;
  /**
   *
   * @type {number}
   * @memberof CrupdateCar
   */
  price: number;
  /**
   *
   * @type {Array<string>}
   * @memberof CrupdateCar
   */
  color: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CrupdateCar
   */
  motorType: CrupdateCarMotorTypeEnum;
  /**
   *
   * @type {number}
   * @memberof CrupdateCar
   */
  power: number;
  /**
   *
   * @type {number}
   * @memberof CrupdateCar
   */
  placeNumber: number;
  /**
   *
   * @type {boolean}
   * @memberof CrupdateCar
   */
  status: boolean;
  /**
   *
   * @type {string}
   * @memberof CrupdateCar
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof CrupdateCar
   */
  brandId: string;
}

export const CrupdateCarMotorTypeEnum = {
  Gasoline: "GASOLINE",
  Diesel: "DIESEL",
  Hybrid: "HYBRID",
  Electric: "ELECTRIC",
} as const;

export type CrupdateCarMotorTypeEnum =
  (typeof CrupdateCarMotorTypeEnum)[keyof typeof CrupdateCarMotorTypeEnum];

/**
 *
 * @export
 * @interface Dummy
 */
export interface Dummy {
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Dummy
   */
  name: string;
}
/**
 *
 * @export
 * @interface Image
 */
export interface Image {
  /**
   *
   * @type {string}
   * @memberof Image
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof Image
   */
  url: string;
  /**
   *
   * @type {string}
   * @memberof Image
   */
  name: string;
}
/**
 *
 * @export
 * @interface UpdateProfile
 */
export interface UpdateProfile {
  /**
   *
   * @type {string}
   * @memberof UpdateProfile
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UpdateProfile
   */
  picture?: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  picture?: string;
}

/**
 * AppointmentsApi - axios parameter creator
 * @export
 */
export const AppointmentsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {Appointment} appointment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAppointments: async (
      appointment: Appointment,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'appointment' is not null or undefined
      assertParamExists("crupdateAppointments", "appointment", appointment);
      const localVarPath = `/appointments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        appointment,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAppointmentById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteAppointmentById", "id", id);
      const localVarPath = `/appointments/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointmentById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getAppointmentById", "id", id);
      const localVarPath = `/appointment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [status]
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointments: async (
      status?: string,
      name?: string,
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/appointments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AppointmentsApi - functional programming interface
 * @export
 */
export const AppointmentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AppointmentsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {Appointment} appointment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateAppointments(
      appointment: Appointment,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateAppointments(
          appointment,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AppointmentsApi.crupdateAppointments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAppointmentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAppointmentById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AppointmentsApi.deleteAppointmentById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppointmentById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAppointmentById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AppointmentsApi.getAppointmentById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [status]
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAppointments(
      status?: string,
      name?: string,
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Appointment>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAppointments(
        status,
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["AppointmentsApi.getAppointments"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AppointmentsApi - factory interface
 * @export
 */
export const AppointmentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AppointmentsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {Appointment} appointment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateAppointments(
      appointment: Appointment,
      options?: any
    ): AxiosPromise<Appointment> {
      return localVarFp
        .crupdateAppointments(appointment, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAppointmentById(
      id: string,
      options?: any
    ): AxiosPromise<Appointment> {
      return localVarFp
        .deleteAppointmentById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointmentById(id: string, options?: any): AxiosPromise<Appointment> {
      return localVarFp
        .getAppointmentById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [status]
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAppointments(
      status?: string,
      name?: string,
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<Array<Appointment>> {
      return localVarFp
        .getAppointments(status, name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AppointmentsApi - object-oriented interface
 * @export
 * @class AppointmentsApi
 * @extends {BaseAPI}
 */
export class AppointmentsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {Appointment} appointment
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentsApi
   */
  public crupdateAppointments(
    appointment: Appointment,
    options?: RawAxiosRequestConfig
  ) {
    return AppointmentsApiFp(this.configuration)
      .crupdateAppointments(appointment, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentsApi
   */
  public deleteAppointmentById(id: string, options?: RawAxiosRequestConfig) {
    return AppointmentsApiFp(this.configuration)
      .deleteAppointmentById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentsApi
   */
  public getAppointmentById(id: string, options?: RawAxiosRequestConfig) {
    return AppointmentsApiFp(this.configuration)
      .getAppointmentById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [status]
   * @param {string} [name]
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppointmentsApi
   */
  public getAppointments(
    status?: string,
    name?: string,
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return AppointmentsApiFp(this.configuration)
      .getAppointments(status, name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CarsApi - axios parameter creator
 * @export
 */
export const CarsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {CrupdateCar} crupdateCar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCar: async (
      crupdateCar: CrupdateCar,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'crupdateCar' is not null or undefined
      assertParamExists("crupdateCar", "crupdateCar", crupdateCar);
      const localVarPath = `/cars`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        crupdateCar,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {CarBrand} carBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCarBrands: async (
      carBrand: CarBrand,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'carBrand' is not null or undefined
      assertParamExists("crupdateCarBrands", "carBrand", carBrand);
      const localVarPath = `/cars/brands`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        carBrand,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCarBrand: async (
      id: string,
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteCarBrand", "id", id);
      const localVarPath = `/cars/brands/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCarById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteCarById", "id", id);
      const localVarPath = `/cars/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCarBrands: async (
      name?: string,
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/cars/brands`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCarBrandsById: async (
      id: string,
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getCarBrandsById", "id", id);
      const localVarPath = `/cars/brands/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCarById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getCarById", "id", id);
      const localVarPath = `/cars/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [brandName]
     * @param {GetCarsMotorTypeEnum} [motorType]
     * @param {string} [type]
     * @param {string} [model]
     * @param {number} [priceFrom]
     * @param {number} [priceTo]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCars: async (
      brandName?: string,
      motorType?: GetCarsMotorTypeEnum,
      type?: string,
      model?: string,
      priceFrom?: number,
      priceTo?: number,
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/cars`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (brandName !== undefined) {
        localVarQueryParameter["brandName"] = brandName;
      }

      if (motorType !== undefined) {
        localVarQueryParameter["motorType"] = motorType;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (model !== undefined) {
        localVarQueryParameter["model"] = model;
      }

      if (priceFrom !== undefined) {
        localVarQueryParameter["priceFrom"] = priceFrom;
      }

      if (priceTo !== undefined) {
        localVarQueryParameter["priceTo"] = priceTo;
      }

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CarsApi - functional programming interface
 * @export
 */
export const CarsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CarsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {CrupdateCar} crupdateCar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateCar(
      crupdateCar: CrupdateCar,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Car>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateCar(
        crupdateCar,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.crupdateCar"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {CarBrand} carBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crupdateCarBrands(
      carBrand: CarBrand,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarBrand>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.crupdateCarBrands(carBrand, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.crupdateCarBrands"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCarBrand(
      id: string,
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarBrand>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCarBrand(
        id,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.deleteCarBrand"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCarById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Car>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCarById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.deleteCarById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCarBrands(
      name?: string,
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CarBrand>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCarBrands(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.getCarBrands"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCarBrandsById(
      id: string,
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarBrand>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCarBrandsById(
          id,
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.getCarBrandsById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCarById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Car>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCarById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.getCarById"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [brandName]
     * @param {GetCarsMotorTypeEnum} [motorType]
     * @param {string} [type]
     * @param {string} [model]
     * @param {number} [priceFrom]
     * @param {number} [priceTo]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCars(
      brandName?: string,
      motorType?: GetCarsMotorTypeEnum,
      type?: string,
      model?: string,
      priceFrom?: number,
      priceTo?: number,
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Car>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCars(
        brandName,
        motorType,
        type,
        model,
        priceFrom,
        priceTo,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["CarsApi.getCars"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CarsApi - factory interface
 * @export
 */
export const CarsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CarsApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {CrupdateCar} crupdateCar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCar(crupdateCar: CrupdateCar, options?: any): AxiosPromise<Car> {
      return localVarFp
        .crupdateCar(crupdateCar, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {CarBrand} carBrand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crupdateCarBrands(
      carBrand: CarBrand,
      options?: any
    ): AxiosPromise<CarBrand> {
      return localVarFp
        .crupdateCarBrands(carBrand, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCarBrand(
      id: string,
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<CarBrand> {
      return localVarFp
        .deleteCarBrand(id, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCarById(id: string, options?: any): AxiosPromise<Car> {
      return localVarFp
        .deleteCarById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCarBrands(
      name?: string,
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<Array<CarBrand>> {
      return localVarFp
        .getCarBrands(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCarBrandsById(
      id: string,
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<CarBrand> {
      return localVarFp
        .getCarBrandsById(id, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCarById(id: string, options?: any): AxiosPromise<Car> {
      return localVarFp
        .getCarById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [brandName]
     * @param {GetCarsMotorTypeEnum} [motorType]
     * @param {string} [type]
     * @param {string} [model]
     * @param {number} [priceFrom]
     * @param {number} [priceTo]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCars(
      brandName?: string,
      motorType?: GetCarsMotorTypeEnum,
      type?: string,
      model?: string,
      priceFrom?: number,
      priceTo?: number,
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<Array<Car>> {
      return localVarFp
        .getCars(
          brandName,
          motorType,
          type,
          model,
          priceFrom,
          priceTo,
          page,
          pageSize,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CarsApi - object-oriented interface
 * @export
 * @class CarsApi
 * @extends {BaseAPI}
 */
export class CarsApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {CrupdateCar} crupdateCar
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public crupdateCar(
    crupdateCar: CrupdateCar,
    options?: RawAxiosRequestConfig
  ) {
    return CarsApiFp(this.configuration)
      .crupdateCar(crupdateCar, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {CarBrand} carBrand
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public crupdateCarBrands(
    carBrand: CarBrand,
    options?: RawAxiosRequestConfig
  ) {
    return CarsApiFp(this.configuration)
      .crupdateCarBrands(carBrand, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public deleteCarBrand(
    id: string,
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return CarsApiFp(this.configuration)
      .deleteCarBrand(id, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public deleteCarById(id: string, options?: RawAxiosRequestConfig) {
    return CarsApiFp(this.configuration)
      .deleteCarById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public getCarBrands(
    name?: string,
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return CarsApiFp(this.configuration)
      .getCarBrands(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public getCarBrandsById(
    id: string,
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return CarsApiFp(this.configuration)
      .getCarBrandsById(id, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public getCarById(id: string, options?: RawAxiosRequestConfig) {
    return CarsApiFp(this.configuration)
      .getCarById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [brandName]
   * @param {GetCarsMotorTypeEnum} [motorType]
   * @param {string} [type]
   * @param {string} [model]
   * @param {number} [priceFrom]
   * @param {number} [priceTo]
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CarsApi
   */
  public getCars(
    brandName?: string,
    motorType?: GetCarsMotorTypeEnum,
    type?: string,
    model?: string,
    priceFrom?: number,
    priceTo?: number,
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return CarsApiFp(this.configuration)
      .getCars(
        brandName,
        motorType,
        type,
        model,
        priceFrom,
        priceTo,
        page,
        pageSize,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GetCarsMotorTypeEnum = {
  Diesel: "DIESEL",
  Electric: "ELECTRIC",
  Gasoline: "GASOLINE",
  Hybrid: "HYBRID",
} as const;
export type GetCarsMotorTypeEnum =
  (typeof GetCarsMotorTypeEnum)[keyof typeof GetCarsMotorTypeEnum];

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies: async (
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dummies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateDummies: async (
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/dummies/private`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDummies(
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dummy>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDummies(
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.getDummies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivateDummies(
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dummy>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPrivateDummies(
          page,
          pageSize,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.getPrivateDummies"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["HealthApi.ping"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = HealthApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDummies(
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<Array<Dummy>> {
      return localVarFp
        .getDummies(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateDummies(
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<Array<Dummy>> {
      return localVarFp
        .getPrivateDummies(page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(options?: any): AxiosPromise<string> {
      return localVarFp
        .ping(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getDummies(
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return HealthApiFp(this.configuration)
      .getDummies(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public getPrivateDummies(
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return HealthApiFp(this.configuration)
      .getPrivateDummies(page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public ping(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .ping(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImageById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("deleteImageById", "id", id);
      const localVarPath = `/images/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("get", "id", id);
      const localVarPath = `/images/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImages: async (
      name?: string,
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {Array<Image>} image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOrUpdate: async (
      image: Array<Image>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'image' is not null or undefined
      assertParamExists("saveOrUpdate", "image", image);
      const localVarPath = `/images`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        image,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteImageById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteImageById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ImagesApi.deleteImageById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ImagesApi.get"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getImages(
      name?: string,
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getImages(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ImagesApi.getImages"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {Array<Image>} image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveOrUpdate(
      image: Array<Image>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveOrUpdate(
        image,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["ImagesApi.saveOrUpdate"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ImagesApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteImageById(id: string, options?: any): AxiosPromise<Image> {
      return localVarFp
        .deleteImageById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(id: string, options?: any): AxiosPromise<Image> {
      return localVarFp
        .get(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImages(
      name?: string,
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<Array<Image>> {
      return localVarFp
        .getImages(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {Array<Image>} image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveOrUpdate(
      image: Array<Image>,
      options?: any
    ): AxiosPromise<Array<Image>> {
      return localVarFp
        .saveOrUpdate(image, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public deleteImageById(id: string, options?: RawAxiosRequestConfig) {
    return ImagesApiFp(this.configuration)
      .deleteImageById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public get(id: string, options?: RawAxiosRequestConfig) {
    return ImagesApiFp(this.configuration)
      .get(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public getImages(
    name?: string,
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return ImagesApiFp(this.configuration)
      .getImages(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {Array<Image>} image
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImagesApi
   */
  public saveOrUpdate(image: Array<Image>, options?: RawAxiosRequestConfig) {
    return ImagesApiFp(this.configuration)
      .saveOrUpdate(image, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/whoami`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
  return {
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["SecurityApi.whoami"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SecurityApiFp(configuration);
  return {
    /**
     * Tell who you are
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: any): AxiosPromise<User> {
      return localVarFp
        .whoami(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
  /**
   * Tell who you are
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityApi
   */
  public whoami(options?: RawAxiosRequestConfig) {
    return SecurityApiFp(this.configuration)
      .whoami(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("getUserById", "id", id);
      const localVarPath = `/users/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      name?: string,
      page?: any,
      pageSize?: any,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (page !== undefined) {
        for (const [key, value] of Object.entries(page)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (pageSize !== undefined) {
        for (const [key, value] of Object.entries(pageSize)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary
     * @param {UpdateProfile} updateProfile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfile: async (
      updateProfile: UpdateProfile,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateProfile' is not null or undefined
      assertParamExists("updateProfile", "updateProfile", updateProfile);
      const localVarPath = `/profile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProfile,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserById(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(
        id,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUserById"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      name?: string,
      page?: any,
      pageSize?: any,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        name,
        page,
        pageSize,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.getUsers"]?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary
     * @param {UpdateProfile} updateProfile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProfile(
      updateProfile: UpdateProfile,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(
        updateProfile,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap["UsersApi.updateProfile"]?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserById(id: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserById(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {string} [name]
     * @param {any} [page]
     * @param {any} [pageSize]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      name?: string,
      page?: any,
      pageSize?: any,
      options?: any
    ): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(name, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary
     * @param {UpdateProfile} updateProfile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfile(
      updateProfile: UpdateProfile,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .updateProfile(updateProfile, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserById(id: string, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUserById(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {string} [name]
   * @param {any} [page]
   * @param {any} [pageSize]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(
    name?: string,
    page?: any,
    pageSize?: any,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .getUsers(name, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary
   * @param {UpdateProfile} updateProfile
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateProfile(
    updateProfile: UpdateProfile,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateProfile(updateProfile, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
